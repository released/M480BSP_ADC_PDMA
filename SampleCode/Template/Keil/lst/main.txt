; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.ADC_Convert_Ext_Channel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  ADC_Convert_Ext_Channel PROC
;;;211    
;;;212    void ADC_Convert_Ext_Channel(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;213    {
;;;214    	uint8_t i = 0;
;;;215    
;;;216    	uint8_t SampleCount = 0;
;;;217    	uint8_t ModuleCount = 0;
;;;218    	uint8_t ModuleNum = ADC0_CH7;
;;;219    	
;;;220    	set_flag(flag_Trans_Data_Ready , DISABLE);	
000004  4f37              LDR      r7,|L1.228|
;;;221    	set_flag(flag_ADC_Data_Ready , DISABLE);
;;;222    	
;;;223        /* Set input mode as single-end, and Single mode*/
;;;224        EADC_Open(EADC, EADC_CTL_DIFFEN_SINGLE_END);
000006  4d38              LDR      r5,|L1.232|
000008  2400              MOVS     r4,#0                 ;216
00000a  6938              LDR      r0,[r7,#0x10]         ;221  ; BitFlag
00000c  2607              MOVS     r6,#7                 ;218
00000e  f020000a          BIC      r0,r0,#0xa            ;221
000012  6138              STR      r0,[r7,#0x10]  ; BitFlag
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       EADC_Open
;;;225    
;;;226    	EADC_ConfigSampleModule(EADC, ModuleNum, EADC_SOFTWARE_TRIGGER, ADC0_CH7);
00001c  2307              MOVS     r3,#7
00001e  2200              MOVS     r2,#0
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       EADC_ConfigSampleModule
;;;227    	EADC_ConfigSampleModule(EADC, ModuleNum+1, EADC_ADINT0_TRIGGER, ADC0_CH8);
000028  2308              MOVS     r3,#8
00002a  039e              LSLS     r6,r3,#14
00002c  4632              MOV      r2,r6
00002e  4619              MOV      r1,r3
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       EADC_ConfigSampleModule
;;;228    	EADC_ConfigSampleModule(EADC, ModuleNum+2, EADC_ADINT0_TRIGGER, ADC0_CH9);
000036  2309              MOVS     r3,#9
000038  4632              MOV      r2,r6
00003a  4619              MOV      r1,r3
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       EADC_ConfigSampleModule
;;;229    	EADC_ConfigSampleModule(EADC, ModuleNum+3, EADC_ADINT0_TRIGGER, ADC0_CH10);
000042  230a              MOVS     r3,#0xa
000044  4632              MOV      r2,r6
000046  4619              MOV      r1,r3
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       EADC_ConfigSampleModule
;;;230    
;;;231        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);
00004e  2001              MOVS     r0,#1
000050  f8c500f8          STR      r0,[r5,#0xf8]
;;;232        EADC_ENABLE_INT(EADC, BIT0);
000054  6d28              LDR      r0,[r5,#0x50]
000056  f0400004          ORR      r0,r0,#4
00005a  6528              STR      r0,[r5,#0x50]
;;;233        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 0, (BIT0 << ModuleNum));
00005c  f8d500d0          LDR      r0,[r5,#0xd0]
000060  2680              MOVS     r6,#0x80
000062  f0400080          ORR      r0,r0,#0x80
000066  f8c500d0          STR      r0,[r5,#0xd0]
;;;234    
;;;235        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF1_Msk);
00006a  2002              MOVS     r0,#2
00006c  f8c500f8          STR      r0,[r5,#0xf8]
;;;236        EADC_ENABLE_INT(EADC, BIT1);
000070  6d28              LDR      r0,[r5,#0x50]
000072  f0400008          ORR      r0,r0,#8
000076  6528              STR      r0,[r5,#0x50]
;;;237        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 1, (BIT0 << (ModuleNum+3)));
000078  f8d500d4          LDR      r0,[r5,#0xd4]
00007c  f4406080          ORR      r0,r0,#0x400
000080  f8c500d4          STR      r0,[r5,#0xd4]
;;;238    
;;;239        NVIC_EnableIRQ(EADC00_IRQn);
000084  202a              MOVS     r0,#0x2a
000086  f7fffffe          BL       NVIC_EnableIRQ
;;;240        NVIC_EnableIRQ(EADC01_IRQn);
00008a  202b              MOVS     r0,#0x2b
00008c  f7fffffe          BL       NVIC_EnableIRQ
;;;241    	
;;;242    	PDMA_Init();
000090  f7fffffe          BL       PDMA_Init
;;;243    
;;;244        EADC_START_CONV(EADC, (BIT0 << ADC0_CH7));
000094  656e              STR      r6,[r5,#0x54]
;;;245    //	while(is_flag_set(flag_ADC_Data_Ready) == DISABLE);
;;;246    
;;;247    	for (ModuleCount = ADC0_CH7 , SampleCount = 0; ModuleCount < (ADC0_CH7 + ADC_DMA_SAMPLE_COUNT) ; ModuleCount++, SampleCount++)
000096  2007              MOVS     r0,#7
;;;248    	{
;;;249    		aADCxConvertedData[SampleCount] = EADC_GET_CONV_DATA(EADC, ModuleCount);
000098  f1070614          ADD      r6,r7,#0x14
                  |L1.156|
00009c  f8551020          LDR      r1,[r5,r0,LSL #2]
0000a0  f8261014          STRH     r1,[r6,r4,LSL #1]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  1c64              ADDS     r4,r4,#1              ;247
0000a8  b2c0              UXTB     r0,r0                 ;247
0000aa  b2e4              UXTB     r4,r4                 ;247
0000ac  280b              CMP      r0,#0xb               ;247
0000ae  d3f5              BCC      |L1.156|
;;;250    	}
;;;251    
;;;252    
;;;253    //    while(is_flag_set(flag_Trans_Data_Ready) == DISABLE);
;;;254    	for (i = 0 ; i < ADC_DMA_SAMPLE_COUNT; i++)
;;;255    	{
;;;256    		printf("0x%3X,0x%3X,|" , aADCxConvertedData[i],pdmaConvertedData[i] );
0000b0  4d0c              LDR      r5,|L1.228|
0000b2  2400              MOVS     r4,#0                 ;254
0000b4  351c              ADDS     r5,r5,#0x1c
                  |L1.182|
0000b6  f8361014          LDRH     r1,[r6,r4,LSL #1]
0000ba  f8352014          LDRH     r2,[r5,r4,LSL #1]
0000be  a00b              ADR      r0,|L1.236|
0000c0  f7fffffe          BL       __2printf
0000c4  1c64              ADDS     r4,r4,#1
0000c6  b2e4              UXTB     r4,r4                 ;254
0000c8  2c04              CMP      r4,#4                 ;254
0000ca  d3f4              BCC      |L1.182|
;;;257    	}
;;;258    
;;;259    	printf(" , 0x%3X,0x%3X,0x%3X" , Vgap , Vtemp, Vbat);
0000cc  1d3f              ADDS     r7,r7,#4
0000ce  a00b              ADR      r0,|L1.252|
0000d0  e897000e          LDM      r7,{r1-r3}
0000d4  f7fffffe          BL       __2printf
;;;260    
;;;261    	printf("\r\n");
0000d8  e8bd41f0          POP      {r4-r8,lr}
0000dc  a00d              ADR      r0,|L1.276|
0000de  f7ffbffe          B.W      __2printf
;;;262    	
;;;263    }
;;;264    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L1.228|
                          DCD      ||.data||
                  |L1.232|
                          DCD      0x40043000
                  |L1.236|
0000ec  30782533          DCB      "0x%3X,0x%3X,|",0
0000f0  582c3078
0000f4  2533582c
0000f8  7c00    
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L1.252|
0000fc  202c2030          DCB      " , 0x%3X,0x%3X,0x%3X",0
000100  78253358
000104  2c307825
000108  33582c30
00010c  78253358
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L1.276|
000114  0d0a00            DCB      "\r\n",0
000117  00                DCB      0

                          AREA ||i.ADC_Read_Int_Channel||, CODE, READONLY, ALIGN=2

                  ADC_Read_Int_Channel PROC
;;;179    
;;;180    void ADC_Read_Int_Channel(void)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
;;;182    	set_flag(flag_ADC_Sensor_Ready , DISABLE);
000002  4d23              LDR      r5,|L2.144|
;;;183    	
;;;184       /* Set input mode as single-end and enable the A/D converter */
;;;185        EADC_Open(EADC, EADC_CTL_DIFFEN_SINGLE_END);
000004  4c23              LDR      r4,|L2.148|
000006  2100              MOVS     r1,#0
000008  6928              LDR      r0,[r5,#0x10]         ;182  ; BitFlag
00000a  f0200004          BIC      r0,r0,#4              ;182
00000e  6128              STR      r0,[r5,#0x10]  ; BitFlag
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       EADC_Open
;;;186    
;;;187        /* Set sample module 16 external sampling time to 0xF */
;;;188        EADC_SetExtendSampleTime(EADC, ADC0_CH16_BAND_GAP_VOLT, 0x3F);
000016  223f              MOVS     r2,#0x3f
000018  2110              MOVS     r1,#0x10
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EADC_SetExtendSampleTime
;;;189        EADC_SetExtendSampleTime(EADC, ADC0_CH17_TEMP_SENSOR, 0x3F);
000020  223f              MOVS     r2,#0x3f
000022  2111              MOVS     r1,#0x11
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       EADC_SetExtendSampleTime
;;;190    
;;;191        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF2_Msk);
00002a  2004              MOVS     r0,#4
00002c  f8c400f8          STR      r0,[r4,#0xf8]
;;;192        EADC_ENABLE_INT(EADC, (BIT0 << 2));
000030  6d20              LDR      r0,[r4,#0x50]
000032  f0400010          ORR      r0,r0,#0x10
000036  6520              STR      r0,[r4,#0x50]
;;;193        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 2, (BIT0 << ADC0_CH16_BAND_GAP_VOLT));
000038  f8d400d8          LDR      r0,[r4,#0xd8]
00003c  f4403080          ORR      r0,r0,#0x10000
000040  f8c400d8          STR      r0,[r4,#0xd8]
;;;194        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 2, (BIT0 << ADC0_CH17_TEMP_SENSOR));
000044  f8d400d8          LDR      r0,[r4,#0xd8]
000048  f4403000          ORR      r0,r0,#0x20000
00004c  f8c400d8          STR      r0,[r4,#0xd8]
;;;195        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 2, (BIT0 << ADC0_CH18_VBAT));
000050  f8d400d8          LDR      r0,[r4,#0xd8]
000054  f4402080          ORR      r0,r0,#0x40000
000058  f8c400d8          STR      r0,[r4,#0xd8]
;;;196    	
;;;197        NVIC_EnableIRQ(EADC02_IRQn);
00005c  202e              MOVS     r0,#0x2e
00005e  f7fffffe          BL       NVIC_EnableIRQ
;;;198    
;;;199        EADC_START_CONV(EADC, (BIT0 << ADC0_CH16_BAND_GAP_VOLT) | (BIT0 << ADC0_CH17_TEMP_SENSOR)| (BIT0 << ADC0_CH18_VBAT));
000062  f44f20e0          MOV      r0,#0x70000
000066  6560              STR      r0,[r4,#0x54]
;;;200    
;;;201    //	while(is_flag_set(flag_ADC_Sensor_Ready) == DISABLE);
;;;202        Vgap = EADC_GET_CONV_DATA(EADC, ADC0_CH16_BAND_GAP_VOLT);
000068  6c20              LDR      r0,[r4,#0x40]
00006a  b280              UXTH     r0,r0
;;;203        Vtemp = EADC_GET_CONV_DATA(EADC, ADC0_CH17_TEMP_SENSOR);
00006c  6068              STR      r0,[r5,#4]  ; Vgap
00006e  6c60              LDR      r0,[r4,#0x44]
000070  b280              UXTH     r0,r0
;;;204        Vbat = EADC_GET_CONV_DATA(EADC, ADC0_CH18_VBAT);
000072  60a8              STR      r0,[r5,#8]  ; Vtemp
000074  6ca0              LDR      r0,[r4,#0x48]
000076  b280              UXTH     r0,r0
;;;205    	
;;;206        EADC_DISABLE_INT(EADC, (BIT0 << 2));
000078  60e8              STR      r0,[r5,#0xc]  ; Vbat
00007a  6d20              LDR      r0,[r4,#0x50]
00007c  f0200010          BIC      r0,r0,#0x10
000080  6520              STR      r0,[r4,#0x50]
000082  4905              LDR      r1,|L2.152|
000084  f44f4080          MOV      r0,#0x4000
000088  f8c10180          STR      r0,[r1,#0x180]
;;;207     	NVIC_DisableIRQ(EADC02_IRQn);
;;;208    	
;;;209    }
00008c  bd70              POP      {r4-r6,pc}
;;;210    
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      ||.data||
                  |L2.148|
                          DCD      0x40043000
                  |L2.152|
                          DCD      0xe000e004

                          AREA ||i.EADC00_IRQHandler||, CODE, READONLY, ALIGN=2

                  EADC00_IRQHandler PROC
;;;161    
;;;162    void EADC00_IRQHandler(void)
000000  4902              LDR      r1,|L3.12|
;;;163    {
;;;164    //    set_flag(flag_ADC_Band_GAP , ENABLE);
;;;165        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);      /* Clear the A/D ADINT0 interrupt flag */
000002  2001              MOVS     r0,#1
000004  f8c100f8          STR      r0,[r1,#0xf8]
;;;166    }
000008  4770              BX       lr
;;;167    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x40043000

                          AREA ||i.EADC01_IRQHandler||, CODE, READONLY, ALIGN=2

                  EADC01_IRQHandler PROC
;;;167    
;;;168    void EADC01_IRQHandler(void)
000000  4902              LDR      r1,|L4.12|
;;;169    {
;;;170    //    set_flag(flag_ADC_Data_Ready , ENABLE);
;;;171        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF1_Msk);
000002  2002              MOVS     r0,#2
000004  f8c100f8          STR      r0,[r1,#0xf8]
;;;172    }
000008  4770              BX       lr
;;;173    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x40043000

                          AREA ||i.EADC02_IRQHandler||, CODE, READONLY, ALIGN=2

                  EADC02_IRQHandler PROC
;;;173    
;;;174    void EADC02_IRQHandler(void)
000000  4902              LDR      r1,|L5.12|
;;;175    {
;;;176    //	set_flag(flag_ADC_Sensor_Ready , ENABLE);
;;;177        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF2_Msk);
000002  2004              MOVS     r0,#4
000004  f8c100f8          STR      r0,[r1,#0xf8]
;;;178    }
000008  4770              BX       lr
;;;179    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40043000

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;309    
;;;310    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;311    {
;;;312    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L6.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;313    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;314    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;315    	
;;;316    }
;;;317    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;87     
;;;88     void PDMA_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
;;;90         uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  4916              LDR      r1,|L8.92|
000004  6808              LDR      r0,[r1,#0]
;;;91     	
;;;92         if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
;;;93         {
;;;94     		#if 0
;;;95             PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
;;;96     		#else
;;;97             if (PDMA_GET_ABORT_STS(PDMA) & ADC_PDMA_OPENED_CH)
;;;98             {
;;;99     			printf("ABTSTS\r\n");
;;;100            }
;;;101            PDMA_CLR_ABORT_FLAG(PDMA, ADC_PDMA_OPENED_CH);
000006  f04f0504          MOV      r5,#4
00000a  07c2              LSLS     r2,r0,#31             ;92
00000c  d008              BEQ      |L8.32|
00000e  1d0c              ADDS     r4,r1,#4              ;97
000010  6820              LDR      r0,[r4,#0]            ;97
000012  0740              LSLS     r0,r0,#29             ;97
000014  d502              BPL      |L8.28|
000016  a012              ADR      r0,|L8.96|
000018  f7fffffe          BL       __2printf
                  |L8.28|
00001c  6025              STR      r5,[r4,#0]
;;;102    
;;;103    		#endif
;;;104        }
;;;105        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;106        {
;;;107            if(PDMA_GET_TD_STS(PDMA) & ADC_PDMA_OPENED_CH)
;;;108            {
;;;109    			//insert process
;;;110    			set_flag(flag_Trans_Data_Ready , ENABLE);
;;;111    			LED_G ^= 1;
;;;112    			
;;;113    //			printf("TDIF\r\n");
;;;114            }        
;;;115    
;;;116    		/* Clear PDMA transfer done interrupt flag */
;;;117    		PDMA_CLR_TD_FLAG(PDMA, ADC_PDMA_OPENED_CH);
;;;118        }
;;;119        else if (status & (PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;120        {
;;;121            PDMA_CLR_TMOUT_FLAG(PDMA,ADC_PDMA_CH);
;;;122    		printf("REQTOF\r\n");
;;;123    
;;;124        }
;;;125        else
;;;126        {
;;;127    
;;;128        }
;;;129    	
;;;130    }
00001e  bd70              POP      {r4-r6,pc}
                  |L8.32|
000020  0782              LSLS     r2,r0,#30             ;105
000022  d510              BPL      |L8.70|
000024  490d              LDR      r1,|L8.92|
000026  3108              ADDS     r1,r1,#8              ;107
000028  6808              LDR      r0,[r1,#0]            ;107
00002a  0740              LSLS     r0,r0,#29             ;107
00002c  d509              BPL      |L8.66|
00002e  480f              LDR      r0,|L8.108|
000030  6902              LDR      r2,[r0,#0x10]         ;110  ; BitFlag
000032  f0420208          ORR      r2,r2,#8              ;110
000036  6102              STR      r2,[r0,#0x10]         ;111  ; BitFlag
000038  480d              LDR      r0,|L8.112|
00003a  6802              LDR      r2,[r0,#0]            ;111
00003c  f0820201          EOR      r2,r2,#1              ;111
000040  6002              STR      r2,[r0,#0]            ;111
                  |L8.66|
000042  600d              STR      r5,[r1,#0]            ;117
                  |L8.68|
000044  bd70              POP      {r4-r6,pc}
                  |L8.70|
000046  0580              LSLS     r0,r0,#22             ;119
000048  d5fc              BPL      |L8.68|
00004a  f44f6080          MOV      r0,#0x400             ;121
00004e  6008              STR      r0,[r1,#0]            ;121
000050  e8bd4070          POP      {r4-r6,lr}            ;122
000054  a007              ADR      r0,|L8.116|
000056  f7ffbffe          B.W      __2printf
;;;131    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      0x4000841c
                  |L8.96|
000060  41425453          DCB      "ABTSTS\r\n",0
000064  54530d0a
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L8.108|
                          DCD      ||.data||
                  |L8.112|
                          DCD      0x400049c8
                  |L8.116|
000074  52455154          DCB      "REQTOF\r\n",0
000078  4f460d0a
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.PDMA_Init||, CODE, READONLY, ALIGN=2

                  PDMA_Init PROC
;;;132    
;;;133    void PDMA_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;134    {
;;;135    	SYS_ResetModule(PDMA_RST);
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       SYS_ResetModule
;;;136    
;;;137        /* Configure PDMA peripheral mode form ADC to memory */
;;;138        /* Open PDMA Channel 1 based on ADC_PDMA_CH setting*/
;;;139        PDMA_Open(PDMA, BIT0 << ADC_PDMA_CH);
000008  4d1a              LDR      r5,|L9.116|
00000a  2104              MOVS     r1,#4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       PDMA_Open
;;;140    
;;;141        /* transfer width is half word(16 bit) and transfer count is ADCDatalenght+1 */
;;;142        PDMA_SetTransferCnt(PDMA, ADC_PDMA_CH, PDMA_WIDTH_16, ADC_DMA_SAMPLE_COUNT);
000012  2304              MOVS     r3,#4
000014  029a              LSLS     r2,r3,#10
000016  2102              MOVS     r1,#2
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       PDMA_SetTransferCnt
;;;143    
;;;144        /* Set source address as ADC data register (no increment) and destination address as g_i32ConversionData array (increment) */
;;;145        PDMA_SetTransferAddr(PDMA, ADC_PDMA_CH, (uint32_t)& (EADC->CURDAT), PDMA_SAR_FIX, (uint32_t)pdmaConvertedData, PDMA_DAR_INC);
00001e  2400              MOVS     r4,#0
000020  4915              LDR      r1,|L9.120|
000022  e9cd1400          STRD     r1,r4,[sp,#0]
000026  f44f7340          MOV      r3,#0x300
00002a  4a14              LDR      r2,|L9.124|
00002c  2102              MOVS     r1,#2
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       PDMA_SetTransferAddr
;;;146    
;;;147        /* Select PDMA request source as ADC RX */
;;;148        PDMA_SetTransferMode(PDMA, ADC_PDMA_CH, PDMA_EADC0_RX, FALSE, 0);
000034  2300              MOVS     r3,#0
000036  2232              MOVS     r2,#0x32
000038  2102              MOVS     r1,#2
00003a  4628              MOV      r0,r5
00003c  9400              STR      r4,[sp,#0]
00003e  f7fffffe          BL       PDMA_SetTransferMode
;;;149    
;;;150        /* Set PDMA as single request type for ADC */
;;;151        PDMA_SetBurstType(PDMA, ADC_PDMA_CH, PDMA_REQ_SINGLE, PDMA_BURST_128);
000042  2300              MOVS     r3,#0
000044  2204              MOVS     r2,#4
000046  2102              MOVS     r1,#2
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       PDMA_SetBurstType
;;;152    
;;;153        PDMA_EnableInt(PDMA, ADC_PDMA_CH, PDMA_INT_TRANS_DONE);
00004e  2200              MOVS     r2,#0
000050  2102              MOVS     r1,#2
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       PDMA_EnableInt
;;;154        NVIC_EnableIRQ(PDMA_IRQn);
000058  2028              MOVS     r0,#0x28
00005a  f7fffffe          BL       NVIC_EnableIRQ
;;;155    	
;;;156    	PDMA_Trigger(PDMA , ADC_PDMA_CH);
00005e  2102              MOVS     r1,#2
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       PDMA_Trigger
;;;157    
;;;158        /* ADC enable PDMA transfer */
;;;159        EADC_ENABLE_PDMA(EADC);
000066  4805              LDR      r0,|L9.124|
000068  384c              SUBS     r0,r0,#0x4c
00006a  6d01              LDR      r1,[r0,#0x50]
00006c  f4416100          ORR      r1,r1,#0x800
000070  6501              STR      r1,[r0,#0x50]
;;;160    }
000072  bd7c              POP      {r2-r6,pc}
;;;161    
                          ENDP

                  |L9.116|
                          DCD      0x40008000
                  |L9.120|
                          DCD      ||.data||+0x1c
                  |L9.124|
                          DCD      0x4004304c

                          AREA ||i.ReloadPDMA||, CODE, READONLY, ALIGN=2

                  ReloadPDMA PROC
;;;78     
;;;79     void ReloadPDMA(void)
000000  b538              PUSH     {r3-r5,lr}
;;;80     {
;;;81         /* transfer width is half word(16 bit) and transfer count is ADCDatalenght+1 */
;;;82         PDMA_SetTransferCnt(PDMA, ADC_PDMA_CH, PDMA_WIDTH_16, ADC_DMA_SAMPLE_COUNT);
000002  4c08              LDR      r4,|L10.36|
000004  2304              MOVS     r3,#4
000006  029a              LSLS     r2,r3,#10
000008  2102              MOVS     r1,#2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       PDMA_SetTransferCnt
;;;83     
;;;84         /* Select PDMA request source as ADC RX */
;;;85         PDMA_SetTransferMode(PDMA, ADC_PDMA_CH, PDMA_EADC0_RX, FALSE, (uint32_t) 0);
000010  2100              MOVS     r1,#0
000012  460b              MOV      r3,r1
000014  9100              STR      r1,[sp,#0]
000016  2232              MOVS     r2,#0x32
000018  2102              MOVS     r1,#2
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       PDMA_SetTransferMode
;;;86     }
000020  bd38              POP      {r3-r5,pc}
;;;87     
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      0x40008000

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;317    
;;;318    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L11.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L11.10|
;;;319    {
;;;320        /*---------------------------------------------------------------------------------------------------------*/
;;;321        /* Init System Clock                                                                                       */
;;;322        /*---------------------------------------------------------------------------------------------------------*/
;;;323        /* Unlock protected registers */
;;;324        SYS_UnlockReg();
;;;325    
;;;326        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;327        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;328    
;;;329        /* Enable External XTAL (4~24 MHz) */
;;;330        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;331    
;;;332        /* Waiting for 12MHz clock ready */
;;;333        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;334    
;;;335        /* Set core clock as PLL_CLOCK from PLL */
;;;336        CLK_SetCoreClock(FREQ_192MHZ);
00003a  4827              LDR      r0,|L11.216|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;337        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;338        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;339    
;;;340        /* Enable UART clock */
;;;341        CLK_EnableModuleClock(UART0_MODULE);
000046  4e25              LDR      r6,|L11.220|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;342    
;;;343        /* Select UART clock source from HXT */
;;;344        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;345    
;;;346        /* Enable EADC module clock */
;;;347        CLK_EnableModuleClock(EADC_MODULE);
000058  4e21              LDR      r6,|L11.224|
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       CLK_EnableModuleClock
;;;348    
;;;349        /* EADC clock source is 96MHz, set divider to 8, EADC clock is 96/8 MHz */
;;;350        CLK_SetModuleClock(EADC_MODULE, 0, CLK_CLKDIV0_EADC(8));
000060  f44f22e0          MOV      r2,#0x70000
000064  2100              MOVS     r1,#0
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       CLK_SetModuleClock
;;;351    
;;;352        CLK_EnableModuleClock(PDMA_MODULE);
00006c  2001              MOVS     r0,#1
00006e  f7fffffe          BL       CLK_EnableModuleClock
;;;353    
;;;354    	TIMER0_HW_Init();
000072  f7fffffe          BL       TIMER0_HW_Init
;;;355    	TIMER1_HW_Init();
000076  f7fffffe          BL       TIMER1_HW_Init
;;;356    	
;;;357        /* Update System Core Clock */
;;;358        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;359        SystemCoreClockUpdate();
00007a  f7fffffe          BL       SystemCoreClockUpdate
;;;360    
;;;361        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;362        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
00007e  6be0              LDR      r0,[r4,#0x3c]
000080  f420007f          BIC      r0,r0,#0xff0000
000084  63e0              STR      r0,[r4,#0x3c]
;;;363        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000086  6be0              LDR      r0,[r4,#0x3c]
000088  f44000cc          ORR      r0,r0,#0x660000
00008c  63e0              STR      r0,[r4,#0x3c]
;;;364    
;;;365        PB->MODE &= ~(GPIO_MODE_MODE7_Msk | GPIO_MODE_MODE8_Msk | GPIO_MODE_MODE9_Msk | GPIO_MODE_MODE10_Msk);
00008e  6c28              LDR      r0,[r5,#0x40]
000090  f420107f          BIC      r0,r0,#0x3fc000
000094  6428              STR      r0,[r5,#0x40]
;;;366    
;;;367        SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB7MFP_Msk );
000096  6ba0              LDR      r0,[r4,#0x38]
000098  f0204070          BIC      r0,r0,#0xf0000000
00009c  63a0              STR      r0,[r4,#0x38]
;;;368        SYS->GPB_MFPL |= (SYS_GPB_MFPL_PB7MFP_EADC0_CH7);
00009e  6ba0              LDR      r0,[r4,#0x38]
0000a0  f0405080          ORR      r0,r0,#0x10000000
0000a4  63a0              STR      r0,[r4,#0x38]
;;;369    
;;;370        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB8MFP_Msk | SYS_GPB_MFPH_PB9MFP_Msk | SYS_GPB_MFPH_PB10MFP_Msk);
0000a6  6be0              LDR      r0,[r4,#0x3c]
0000a8  f36f000b          BFC      r0,#0,#12
0000ac  63e0              STR      r0,[r4,#0x3c]
;;;371        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB8MFP_EADC0_CH8 | SYS_GPB_MFPH_PB9MFP_EADC0_CH9 | SYS_GPB_MFPH_PB10MFP_EADC0_CH10);
0000ae  6be0              LDR      r0,[r4,#0x3c]
0000b0  f2401111          MOV      r1,#0x111
0000b4  4308              ORRS     r0,r0,r1
0000b6  63e0              STR      r0,[r4,#0x3c]
;;;372    
;;;373        /* Disable the GPB0 - GPB3 digital input path to avoid the leakage current. */
;;;374        GPIO_DISABLE_DIGITAL_PATH(PB, BIT10|BIT9|BIT8|BIT7);
0000b8  6c68              LDR      r0,[r5,#0x44]
0000ba  f04060f0          ORR      r0,r0,#0x7800000
0000be  6468              STR      r0,[r5,#0x44]
;;;375    
;;;376        /* Enable temperature sensor */
;;;377        SYS->IVSCTL |= SYS_IVSCTL_VTEMPEN_Msk;
0000c0  69e0              LDR      r0,[r4,#0x1c]
0000c2  f0400001          ORR      r0,r0,#1
0000c6  61e0              STR      r0,[r4,#0x1c]
;;;378    
;;;379        /* Set reference voltage to external pin (3.3V) */
;;;380        SYS_SetVRef(SYS_VREFCTL_VREF_PIN);
0000c8  2000              MOVS     r0,#0
0000ca  f7fffffe          BL       SYS_SetVRef
0000ce  2000              MOVS     r0,#0
0000d0  f8c40100          STR      r0,[r4,#0x100]
;;;381    	
;;;382        /* Lock protected registers */
;;;383        SYS_LockReg();
;;;384    }
0000d4  bd70              POP      {r4-r6,pc}
;;;385    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L11.216|
                          DCD      0x0b71b000
                  |L11.220|
                          DCD      0x57803d10
                  |L11.224|
                          DCD      0x4003fe1c

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;298    
;;;299    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;300    {
;;;301    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L12.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;302    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;303    }
;;;304    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;304    
;;;305    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;306    {
;;;307    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L13.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;308    }
;;;309    
                          ENDP

                  |L13.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;284    
;;;285    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;286    {
;;;287        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L14.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;288        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;289    }
;;;290    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;290    
;;;291    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L15.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;294        TIMER_EnableInt(TIMER1);
;;;295        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;296        TIMER_Start(TIMER1);
;;;297    }
000028  bd10              POP      {r4,pc}
;;;298    
                          ENDP

00002a  0000              DCW      0x0000
                  |L15.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;265    
;;;266    void TMR1_IRQHandler(void)
000000  480b              LDR      r0,|L16.48|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;267    {
000008  2900              CMP      r1,#0
00000a  d00f              BEQ      |L16.44|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;268    	static uint16_t CNT = 0;	
;;;269    //	static uint32_t log = 0;	
;;;270    	
;;;271        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;272        {
;;;273            TIMER_ClearIntFlag(TIMER1);
;;;274    	
;;;275    		if (CNT++ > 1000)
000010  4908              LDR      r1,|L16.52|
000012  8808              LDRH     r0,[r1,#0]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  800a              STRH     r2,[r1,#0]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d906              BLS      |L16.44|
;;;276    		{		
;;;277    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;278    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;279    //			ADC_Convert_Ext_Channel(ADC0_CH7);
;;;280    			LED_R ^= 1;
000022  4805              LDR      r0,|L16.56|
000024  6801              LDR      r1,[r0,#0]
000026  f0810101          EOR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L16.44|
;;;281    		}
;;;282        }
;;;283    }
00002c  4770              BX       lr
;;;284    
                          ENDP

00002e  0000              DCW      0x0000
                  |L16.48|
                          DCD      0x40050100
                  |L16.52|
                          DCD      ||.data||
                  |L16.56|
                          DCD      0x400049c0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;393    
;;;394    int main()
000000  f7fffffe          BL       SYS_Init
;;;395    {
;;;396    	
;;;397        SYS_Init();
;;;398        /* Init UART to 115200-8n1 for print message */
;;;399        UART_Open(UART0, 115200);
000004  f44f31e1          MOV      r1,#0x1c200
000008  4817              LDR      r0,|L17.104|
00000a  f7fffffe          BL       UART_Open
;;;400    
;;;401    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00000e  f7fffffe          BL       CLK_GetCPUFreq
000012  4601              MOV      r1,r0
000014  a015              ADR      r0,|L17.108|
000016  f7fffffe          BL       __2printf
;;;402    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001a  f7fffffe          BL       CLK_GetHXTFreq
00001e  4601              MOV      r1,r0
000020  a019              ADR      r0,|L17.136|
000022  f7fffffe          BL       __2printf
;;;403    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000026  f7fffffe          BL       CLK_GetLXTFreq
00002a  4601              MOV      r1,r0
00002c  a01c              ADR      r0,|L17.160|
00002e  f7fffffe          BL       __2printf
;;;404    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000032  f7fffffe          BL       CLK_GetPCLK0Freq
000036  4601              MOV      r1,r0
000038  a01f              ADR      r0,|L17.184|
00003a  f7fffffe          BL       __2printf
;;;405    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00003e  f7fffffe          BL       CLK_GetPCLK1Freq
000042  4601              MOV      r1,r0
000044  a023              ADR      r0,|L17.212|
000046  f7fffffe          BL       __2printf
;;;406    
;;;407    
;;;408    	LED_Init();
00004a  f7fffffe          BL       LED_Init
;;;409    	TIMER1_Init();
00004e  f7fffffe          BL       TIMER1_Init
;;;410    
;;;411    
;;;412        /* Got no where to go, just loop forever */
;;;413        while(1)
;;;414        {
;;;415    //		TIMER0_Polling(1000);
;;;416    		LED_Y ^= 1;
000052  4c27              LDR      r4,|L17.240|
                  |L17.84|
000054  6820              LDR      r0,[r4,#0]
000056  f0800001          EOR      r0,r0,#1
00005a  6020              STR      r0,[r4,#0]
;;;417    
;;;418    		ADC_Read_Int_Channel();
00005c  f7fffffe          BL       ADC_Read_Int_Channel
;;;419    		ADC_Convert_Ext_Channel();
000060  f7fffffe          BL       ADC_Convert_Ext_Channel
000064  e7f6              B        |L17.84|
;;;420    	
;;;421        }
;;;422    
;;;423    }
;;;424    
                          ENDP

000066  0000              DCW      0x0000
                  |L17.104|
                          DCD      0x40070000
                  |L17.108|
00006c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000070  4b5f4765
000074  74435055
000078  46726571
00007c  203a2025
000080  38640d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L17.136|
000088  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
00008c  47657448
000090  58544672
000094  6571203a
000098  20253864
00009c  0d0a00  
00009f  00                DCB      0
                  |L17.160|
0000a0  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000a4  4765744c
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L17.184|
0000b8  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000bc  47657450
0000c0  434c4b30
0000c4  46726571
0000c8  203a2025
0000cc  38640d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L17.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b31
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L17.240|
                          DCD      0x400049c4

                          AREA ||.data||, DATA, ALIGN=2

                  ||CNT||
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  Vgap
                          DCD      0x00000000
                  Vtemp
                          DCD      0x00000000
                  Vbat
                          DCD      0x00000000
                  BitFlag
                          DCD      0x00000000
                  aADCxConvertedData
000014  0000              DCW      0x0000
000016  0000              DCB      0x00,0x00
                          DCD      0x00000000
                  pdmaConvertedData
00001c  0000              DCW      0x0000
00001e  0000              DCB      0x00,0x00
                          DCD      0x00000000

                          AREA ||area_number.21||, DATA, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.data||
                  SensorData
000000  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.22||, DATA, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.data||
                  fVDD
000000  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.23||, DATA, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.data||
                  Check
000000  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.24||, DATA, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.data||
                  ADC_CH_TypeDef
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_164135a7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____REVSH|
#line 402
|__asm___6_main_c_164135a7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____RRX|
#line 587
|__asm___6_main_c_164135a7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
